/*
 * TCSS 305 - Assignment 5: RaceDay
 */

package model;

import static model.PropertyChangeEnabledRaceControls.PROPERTY_PARTICIPANT;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.StringTokenizer;

/**
 * Represents an Race object.
 * 
 * @author minhphan
 * @version Fall 2018
 *
 */
public final class Race implements PropertyChangeEnabledRaceControls {

    /** The default starting time. */
    public static final int DEFAULT_START_TIME = 0;
    /** The separator for formatted. */
    public static final String SEPARATOR = ":";
    /** An error message for illegal arguments. */
    private static final String ERROR_MESSAGE = "Time may not be less than 0.";
    /** LeaderBoard String. */
    private static final String LEADERBOARD_L = "$L";
    /** Count between delimiter. */
    private static final int INT_COUNT = 5;
    /** Scanner variable. */
    private static Scanner scanner;

    /** Stores this objects time. */
    private int myTime;

    /**
     * Manager for Property Change Listeners.
     */
    private final PropertyChangeSupport myPcs;

    /** Scanner variable. */
    private Scanner myInput;
    
    private List<RaceInformation> information;

    private List<RaceTrackSize> trackList;
    

    private ParticipantsList myRacerList;


    private Map<Integer, List<Message>> mapList;

    private List<Map<Integer, List<Message>>> rceList;

    private List<Message> message;
    
    private TelementryMessge teleMess;
    
    

    /**
     * Construct race object with a start time of 0.
     */
    public Race() {
        this(DEFAULT_START_TIME);
    }

    /**
     * Construct a race object with a specific start time.
     * 
     * @param theStartTime the start time for this object
     * @throws IllegalArgumentException if theStartTime is < 0
     */
    public Race(final int theStartTime) {
        super();

        if (theStartTime < 0) {
            throw new IllegalArgumentException(ERROR_MESSAGE);

        }
        myPcs = new PropertyChangeSupport(this);

        myTime = theStartTime;

        information = new ArrayList<RaceInformation>();

        trackList = new ArrayList<RaceTrackSize>();

        myRacerList = new ParticipantsList();
        
        rceList = new ArrayList<Map<Integer, List<Message>>>();

        mapList = new HashMap<Integer, List<Message>>();
        
        
        

    }

    @Override
    public void advance() {
        advance(1);
    }

    @Override
    public void advance(final int theMillisecond) {
        changeTime(myTime + theMillisecond);
        
        

    }

    @Override
    public void moveTo(final int theMillisecond) {
        if (theMillisecond < 0) {
            throw new IllegalArgumentException(ERROR_MESSAGE);
        }
        changeTime(theMillisecond);

    }

    /**
     * Helper method to change the value of time and notify observers. Functional
     * decomposition.
     * 
     * @param theMillisecond the time to change to
     */
    public void changeTime(final int theMillisecond) {
        final int old = myTime;
        myTime = theMillisecond;
        myPcs.firePropertyChange(PROPERTY_TIME, old, myTime);

    }

    @Override
    public void toggleParticipant(final int theParticpantID, final boolean theToggle) {
        // TODO Auto-generated method stub

    }

    @Override
    public void loadRace(final File theRaceFile) throws IOException {
     //   checkFile(theRaceFile);
        readFile(theRaceFile);

    }

    /**
     * Scan the header of the file.
     * 
     * @param theInput get the file.
     * @throws IOException throw exception.
     */
    private void readFile(final File theInput) throws IOException {

        final FileReader reader = new FileReader(theInput);
        myInput = new Scanner(reader);

        myInput.useDelimiter(SEPARATOR);
        String[] tokens;
        tokens = myInput.nextLine().split(SEPARATOR);
        final String raceName = tokens[1];
        tokens = myInput.nextLine().split(SEPARATOR);
        final String trackGeometry = tokens[1];
        tokens = myInput.nextLine().split(SEPARATOR);

        final int width = Integer.valueOf(tokens[1]);
        tokens = myInput.nextLine().split(SEPARATOR);

        final int height = Integer.valueOf(tokens[1]);
        tokens = myInput.nextLine().split(SEPARATOR);
        final int distanceOneLap = Integer.valueOf(tokens[1]);
        tokens = myInput.nextLine().split(SEPARATOR);
        final int timeTotal = Integer.valueOf(tokens[1]);
        tokens = myInput.nextLine().split(SEPARATOR);
        final int participant = Integer.valueOf(tokens[1]);

        information.add(new RaceInformation(raceName, trackGeometry, timeTotal,
                                            distanceOneLap));

        trackList.add(new RaceTrackSize(width, height));

        for (int lineCount = 0; lineCount < participant; lineCount++) {
            final String temp = myInput.nextLine();
            final int raceId =
                            Integer.valueOf(temp.split(SEPARATOR)[0].replaceAll("[^0-9]", ""));
            final String name = temp.split(SEPARATOR)[1];
            final double starts = Double.valueOf(temp.split(SEPARATOR)[2]);
            final RaceParticipants racer = new RaceParticipants(raceId, name, starts);
            myRacerList.add(racer);
            //list.add(p);

        }

        while (myInput.hasNextLine()) {
            message = new ArrayList<Message>();
            final String line = myInput.nextLine();
            scanner = extracted(line);
            final Scanner split = scanner.useDelimiter(SEPARATOR);

            final String messageType = split.next();
            final int timeStamp = split.nextInt();

            if (messageType.charAt(1) == 'T') {
                final int raceId = split.nextInt();
                final double distance = split.nextDouble();
                final int lap = split.nextInt();
                teleMess = new TelementryMessge(timeStamp, raceId, distance, lap);
                message.add(teleMess);
                mapList.computeIfAbsent(timeStamp, k -> new ArrayList<>()).add(teleMess);
            } else if (messageType.charAt(1) == 'C') {
                final int raceId = split.nextInt();
                final int newLap = split.nextInt();
                final boolean isFinish = split.nextBoolean();
                final LineCrossingMessge lineMess =
                                new LineCrossingMessge(timeStamp, raceId, newLap, isFinish);
                message.add(lineMess);
                mapList.computeIfAbsent(timeStamp, k -> new ArrayList<>()).add(lineMess);
            } else if (messageType.charAt(1) == 'L') {
                final List<Integer> lbList = new ArrayList<Integer>();
                for (int i = 2; i < participant + 2; i++) {
                    lbList.add(Integer.valueOf(line.split(SEPARATOR)[i]));
                }
                final LeaderboardMessge leaderMess = new LeaderboardMessge(timeStamp, lbList);
                message.add(leaderMess);
                mapList.computeIfAbsent(timeStamp, k -> new ArrayList<>()).add(leaderMess);

            }

            rceList.add(mapList);

        }
//         for(int key : mapList.keySet()) {
//         System.out.println(mapList.get(key));
//         }
       

    }

    public Map<Integer, List<Message>> getMap() {
        return mapList;
    }
    
    public List<String> getRacerName() {
        return myRacerList.getNameList();
    }
    
    public ParticipantsList getRacerList() {     
        return myRacerList;
    }

    
    

//    /**
//     * Check the whole file.
//     * 
//     * @param theInput file user choose.
//     * @throws IOException throw exception when the file is not in format.
//     */
//    public void checkFile(final File theInput) throws IOException {
//        myInput = new Scanner(new FileReader(theInput));
//        int i = 0;
//        int participants = 0;
//        int countParticipants = 0;
//
//        while (myInput.hasNextLine()) {
//            String line = myInput.nextLine();
//
//            final Scanner s = extracted(line).useDelimiter(SEPARATOR);
//
//            final StringTokenizer tokens = new StringTokenizer(line, SEPARATOR);
//
//            final int countTokens = tokens.countTokens();
//
//            if (i == 0 && !(s.next()).startsWith("#RACE")) {
//                extracted();
//            } else if (i == 0 && countTokens != 2) {
//                extracted();
//            } else if (i == 1 && !s.next().startsWith("#TRACK")) {
//                extracted();
//            } else if (i == 1 && countTokens != 2) {
//                extracted();
//            } else if (i == 2 && !s.next().startsWith("#WIDTH")) {
//                extracted();
//            } else if (i == 2 && countTokens != 2) {
//                extracted();
//            } else if (i == 3 && !s.next().startsWith("#HEIGHT")) {
//                extracted();
//            } else if (i == 3 && countTokens != 2) {
//                extracted();
//            } else if (i == 4 && !s.next().startsWith("#DISTANCE")) {
//                extracted();
//            } else if (i == 4 && countTokens != 2) {
//                extracted();
//            } else if (i == 5 && !s.next().startsWith("#TIME")) {
//                extracted();
//            } else if (i == 5 && countTokens != 2) {
//                extracted();
//            } else if (i == 6 && !s.next().startsWith("#PARTICIPANTS")) {
//                extracted();
//            } else if (i == 6 && countTokens != 2) {
//                extracted();
//            }
//
//            if (line.startsWith("#PARTICIPANTS")) {
//                participants = s.nextInt();
//                line = myInput.nextLine();
//                while (!line.startsWith(LEADERBOARD_L)) {
//                    if (!line.startsWith("#")) {
//                        extracted();
//                    }
//                    line = myInput.nextLine();
//
//                    countParticipants++;
//                }
//                if (countParticipants != participants) {
//                    extracted();
//                }
//
//            }
//
//            if (line.startsWith(LEADERBOARD_L)) {
//
//                final StringTokenizer temptok = new StringTokenizer(line, SEPARATOR);
//
//                final int counttemp = temptok.countTokens();
//
//                if (counttemp != (participants + 2)) {
//                    extracted();
//                }
//            }
//            if (line.startsWith("$T")) {
//                final StringTokenizer temptok = new StringTokenizer(line, SEPARATOR);
//
//                final int counttemp = temptok.countTokens();
//
//                if (counttemp != INT_COUNT) {
//                    extracted();
//                }
//            }
//            if (line.startsWith("$C")) {
//                final StringTokenizer temptok = new StringTokenizer(line, SEPARATOR);
//
//                final int counttemp = temptok.countTokens();
//
//                if (counttemp != INT_COUNT) {
//                    extracted();
//
//                }
//
//            }
//            i++;
//        }
//    }

    /**
     * Extracted scanner method.
     * 
     * @param theLine line.
     * @return new line.
     */
    private static Scanner extracted(final String theLine) {
        return new Scanner(theLine);
    }

    /**
     * Extracted IOException method.
     * 
     * @throws IOException throw.
     */
    private void extracted() throws IOException {
        throw new IOException();
    }

    @Override
    public void addPropertyChangeListener(final PropertyChangeListener theListener) {
        myPcs.addPropertyChangeListener(theListener);
    }

    @Override
    public void addPropertyChangeListener(final String thePropertyName,
                                          final PropertyChangeListener theListener) {
        myPcs.addPropertyChangeListener(thePropertyName, theListener);

    }

    @Override
    public void removePropertyChangeListener(final PropertyChangeListener theListener) {
        myPcs.removePropertyChangeListener(theListener);

    }

    @Override
    public void removePropertyChangeListener(final String thePropertyName,
                                             final PropertyChangeListener theListener) {
        myPcs.removePropertyChangeListener(thePropertyName, theListener);

    }

}
