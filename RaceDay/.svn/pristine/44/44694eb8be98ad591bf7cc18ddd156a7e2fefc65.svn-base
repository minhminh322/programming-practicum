/*
 * TCSS 305 - Assignment 5: RaceDay
 */

package model;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * Represents an Race object.
 * 
 * @author minhphan
 * @version Fall 2018
 *
 */
public final class Race implements PropertyChangeEnabledRaceControls {

    /** The default starting time. */
    public static final int DEFAULT_START_TIME = 0;
    /** The separator for formatted. */
    public static final String SEPARATOR = ":";
    /** An error message for illegal arguments. */
    private static final String ERROR_MESSAGE = "Time may not be less than 0.";
    /** Scanner variable. */
    private static Scanner scanner;

    /** Stores this objects time. */
    private int myTime;

    /**
     * Manager for Property Change Listeners.
     */
    private final PropertyChangeSupport myPcs;

    /** Scanner variable. */
    private Scanner myInput;

    /**
     * Construct race object with a start time of 0.
     */
    public Race() {
        this(DEFAULT_START_TIME);
    }

    /**
     * Construct a race object with a specific start time.
     * 
     * @param theStartTime the start time for this object
     * @throws IllegalArgumentException if theStartTime is < 0
     */
    public Race(final int theStartTime) {
        super();

        if (theStartTime < 0) {
            throw new IllegalArgumentException(ERROR_MESSAGE);

        }
        myPcs = new PropertyChangeSupport(this);

        myTime = theStartTime;

    }

    @Override
    public void advance() {
        advance(1);
    }

    @Override
    public void advance(final int theMillisecond) {
        changeTime(myTime + theMillisecond);

    }

    @Override
    public void moveTo(final int theMillisecond) {
        if (theMillisecond < 0) {
            throw new IllegalArgumentException(ERROR_MESSAGE);
        }
        changeTime(theMillisecond);

    }

    /**
     * Helper method to change the value of time and notify observers. Functional
     * decomposition.
     * 
     * @param theMillisecond the time to change to
     */
    public void changeTime(final int theMillisecond) {
        final int old = myTime;
        myTime = theMillisecond;
        myPcs.firePropertyChange(PROPERTY_TIME, old, myTime);

    }

    @Override
    public void toggleParticipant(final int theParticpantID, final boolean theToggle) {
        // TODO Auto-generated method stub

    }

    @Override
    public void loadRace(final File theRaceFile) throws IOException {
        // checkFiles(theRaceFile);
        checkHeader(theRaceFile);

    }

    /**
     * Scan the header of the file.
     * 
     * @param theInput get the file.
     * @throws IOException throw exception.
     */
    private void checkHeader(final File theInput) throws IOException {
        
        final List<RaceInformation> information = new ArrayList<RaceInformation>();
        final ParticipantsList list = new ParticipantsList();

        final List<List<Message>> rceList = new ArrayList<List<Message>>();

        final FileReader reader = new FileReader(theInput);
        myInput = new Scanner(reader);

        myInput.useDelimiter(SEPARATOR);
        String[] tokens;
        tokens = myInput.nextLine().split(SEPARATOR);
        final String raceName = tokens[1];
        tokens = myInput.nextLine().split(SEPARATOR);
        final String trackGeometry = tokens[1];
        tokens = myInput.nextLine().split(SEPARATOR);
        @SuppressWarnings("unused")
        final int width = Integer.valueOf(tokens[1]);
        tokens = myInput.nextLine().split(SEPARATOR);
        @SuppressWarnings("unused")
        final int height = Integer.valueOf(tokens[1]);
        tokens = myInput.nextLine().split(SEPARATOR);
        final int distanceOneLap = Integer.valueOf(tokens[1]);
        tokens = myInput.nextLine().split(SEPARATOR);
        final int timeTotal = Integer.valueOf(tokens[1]);
        tokens = myInput.nextLine().split(SEPARATOR);
        final int participant = Integer.valueOf(tokens[1]);

        information.add(new RaceInformation(raceName, trackGeometry, timeTotal,
                                            distanceOneLap));

        for (int lineCount = 0; lineCount < participant; lineCount++) {
            final String temp = myInput.nextLine();
            final int raceId =
                            Integer.valueOf(temp.split(SEPARATOR)[0].replaceAll("[^0-9]", ""));
            final String name = temp.split(SEPARATOR)[1];
            final double starts = Double.valueOf(temp.split(SEPARATOR)[2]);
            final RaceParticipants p = new RaceParticipants(raceId, name, starts);
            list.add(p);
        }
        list.getListIds();
        list.getListName();
        list.getListStart();

        while (myInput.hasNextLine()) {
            final List<Message> message = new ArrayList<Message>();
            final String line = myInput.nextLine();
            scanner = extracted(line);
            final Scanner split = scanner.useDelimiter(SEPARATOR);

            final String messageType = split.next();
            final int timeStamp = split.nextInt();

            if (messageType.charAt(1) == 'T') {
                final int raceId = split.nextInt();
                final double distance = split.nextDouble();
                final int lap = split.nextInt();
                message.add(new TelementryMessge(timeStamp, raceId, distance, lap));

            } else if (messageType.charAt(1) == 'C') {
                final int raceId = split.nextInt();
                final int newLap = split.nextInt();
                final boolean isFinish = split.nextBoolean();
                message.add(new LineCrossingMessge(timeStamp, raceId, newLap, isFinish));
            } else if (messageType.charAt(1) == 'L') {
                System.out.print("");
                // final List<Integer> LB = new ArrayList<Integer>();
                // for (int i =2 ;i < 10; i++) {
                // LB.add(Integer.valueOf(line.split(SEPARATOR)[i]));
                // }
                // final LeaderboardMessge temp = new LeaderboardMessge(timeStamp, LB);
                // List<Integer> curr = temp.getBoard();
                // for (int i =0 ; i < curr.size();i++) {
                // // System.out.println(curr.get(i));
                // }
                // message.add(temp);
            }

            rceList.add(message);

        }

    }

    /**
     * Extracted scanner method.
     * 
     * @param theLine line.
     * @return new line.
     */
    private static Scanner extracted(final String theLine) {
        return new Scanner(theLine);
    }

    @Override
    public void addPropertyChangeListener(final PropertyChangeListener theListener) {
        myPcs.addPropertyChangeListener(theListener);
    }

    @Override
    public void addPropertyChangeListener(final String thePropertyName,
                                          final PropertyChangeListener theListener) {
        myPcs.addPropertyChangeListener(thePropertyName, theListener);

    }

    @Override
    public void removePropertyChangeListener(final PropertyChangeListener theListener) {
        myPcs.removePropertyChangeListener(theListener);

    }

    @Override
    public void removePropertyChangeListener(final String thePropertyName,
                                             final PropertyChangeListener theListener) {
        myPcs.removePropertyChangeListener(thePropertyName, theListener);

    }

}
